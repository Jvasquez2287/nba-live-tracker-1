"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const dataCache_1 = require("../services/dataCache");
const router = express_1.default.Router();
// Python API base URL (nba-tracker-api)
const PYTHON_API_URL = process.env.PYTHON_API_URL || 'http://nba-v1.m-api.net:8000/api/v1';
// Simple prediction algorithm based on team record
function calculatePrediction(homeTeam, awayTeam) {
    const homeWinPct = homeTeam.wins ? homeTeam.wins / (homeTeam.wins + homeTeam.losses) : 0.5;
    const awayWinPct = awayTeam.wins ? awayTeam.wins / (awayTeam.wins + awayTeam.losses) : 0.5;
    // Home court advantage (about 3% win probability boost)
    const homeAdvantage = 0.03;
    const adjustedHomeWinPct = homeWinPct + homeAdvantage;
    const totalProb = adjustedHomeWinPct + awayWinPct;
    const homeConfidence = (adjustedHomeWinPct / totalProb) * 100;
    const prediction = homeConfidence > 50 ? 'home' : 'away';
    const confidence = Math.max(homeConfidence, 100 - homeConfidence);
    return { prediction, confidence: parseFloat(confidence.toFixed(1)) };
}
// GET /api/v1/predictions - Get game predictions
router.get('/predictions', async (req, res) => {
    try {
        const scoreboardData = await dataCache_1.dataCache.getScoreboard();
        const scoreboard = scoreboardData?.scoreboard;
        if (!scoreboard || !scoreboard.games) {
            return res.json({
                predictions: [],
                lastUpdated: new Date().toISOString()
            });
        }
        const predictions = scoreboard.games
            .filter((game) => game.gameStatus < 3) // Only live/upcoming games
            .map((game) => {
            const { prediction, confidence } = calculatePrediction(game.homeTeam, game.awayTeam);
            return {
                gameId: game.gameId,
                awayTeam: game.awayTeam?.teamName,
                homeTeam: game.homeTeam?.teamName,
                prediction,
                confidence,
                predictedWinner: prediction === 'home' ? game.homeTeam?.teamName : game.awayTeam?.teamName,
                homeTeamRecord: `${game.homeTeam?.wins || 0}-${game.homeTeam?.losses || 0}`,
                awayTeamRecord: `${game.awayTeam?.wins || 0}-${game.awayTeam?.losses || 0}`,
                gameStatus: game.gameStatus,
                gameStatusText: game.gameStatusText
            };
        });
        res.json({
            predictions: predictions.sort((a, b) => b.confidence - a.confidence),
            total: predictions.length,
            lastUpdated: new Date().toISOString()
        });
    }
    catch (error) {
        console.error('Error fetching predictions:', error);
        res.status(500).json({ error: 'Failed to fetch predictions' });
    }
});
// GET /api/v1/predictions/date/:date - Get predictions for a specific date
router.get('/predictions/date/:date', async (req, res) => {
    try {
        const dateParam = req.params.date; // Format: YYYY-MM-DD or gameDate from scoreboard
        const scoreboardData = await dataCache_1.dataCache.getScoreboard();
        const scoreboard = scoreboardData?.scoreboard;
        if (!scoreboard || !scoreboard.games) {
            return res.json({
                date: dateParam,
                predictions: [],
                total: 0,
                lastUpdated: new Date().toISOString()
            });
        }
        // Filter games by date (gameId contains date like 0021900001 where 0021900 = season+date)
        // Or match against gameDate field if available
        const predictions = scoreboard.games
            .filter((game) => {
            // Try to match by gameDate if it exists
            if (game.gameDate === dateParam)
                return true;
            // Try to match by gameId pattern
            if (game.gameId && game.gameId.substring(0, 8) === dateParam.replace(/-/g, '').substring(0, 8))
                return true;
            return false;
        })
            .filter((game) => game.gameStatus < 3) // Only live/upcoming games
            .map((game) => {
            const { prediction, confidence } = calculatePrediction(game.homeTeam, game.awayTeam);
            return {
                gameId: game.gameId,
                awayTeam: game.awayTeam?.teamName,
                homeTeam: game.homeTeam?.teamName,
                prediction,
                confidence,
                predictedWinner: prediction === 'home' ? game.homeTeam?.teamName : game.awayTeam?.teamName,
                homeTeamRecord: `${game.homeTeam?.wins || 0}-${game.homeTeam?.losses || 0}`,
                awayTeamRecord: `${game.awayTeam?.wins || 0}-${game.awayTeam?.losses || 0}`,
                gameStatus: game.gameStatus,
                gameStatusText: game.gameStatusText
            };
        });
        res.json({
            date: dateParam,
            predictions: predictions.sort((a, b) => b.confidence - a.confidence),
            total: predictions.length,
            lastUpdated: new Date().toISOString()
        });
    }
    catch (error) {
        console.error('Error fetching predictions by date:', error);
        res.status(500).json({ error: 'Failed to fetch predictions by date' });
    }
});
// GET /api/v1/predictions/:gameId - Get prediction for specific game
router.get('/predictions/:gameId', async (req, res) => {
    try {
        const gameId = req.params.gameId;
        const scoreboardData = await dataCache_1.dataCache.getScoreboard();
        const scoreboard = scoreboardData?.scoreboard;
        if (!scoreboard || !scoreboard.games) {
            return res.status(404).json({
                error: 'Game not found',
                gameId
            });
        }
        const game = scoreboard.games.find((g) => g.gameId === gameId);
        if (!game) {
            return res.status(404).json({
                error: 'Game not found',
                gameId
            });
        }
        const { prediction, confidence } = calculatePrediction(game.homeTeam, game.awayTeam);
        res.json({
            gameId,
            awayTeam: game.awayTeam?.teamName,
            homeTeam: game.homeTeam?.teamName,
            prediction,
            confidence,
            predictedWinner: prediction === 'home' ? game.homeTeam?.teamName : game.awayTeam?.teamName,
            homeTeamRecord: `${game.homeTeam?.wins || 0}-${game.homeTeam?.losses || 0}`,
            awayTeamRecord: `${game.awayTeam?.wins || 0}-${game.awayTeam?.losses || 0}`,
            gameStatus: game.gameStatus,
            gameStatusText: game.gameStatusText,
            notes: 'Predictions based on team win percentage and home court advantage'
        });
    }
    catch (error) {
        console.error('Error fetching game prediction:', error);
        res.status(500).json({ error: 'Failed to fetch game prediction' });
    }
});
exports.default = router;
//# sourceMappingURL=predictions.js.map